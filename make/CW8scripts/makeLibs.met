-- C libs ------ Properties--property pUsingCPlusPlus : falseproperty pProjectFileExtension : ".mcp"-- Whether to recreate existing project files.property pAlwaysCreateProjects : false-- Which targets to build.-- All of the targets are populated all the time. These affect what is compiled & built.property pCreateCarbonTargets : trueproperty pCreateMachOTargets : trueproperty pCreateWinTargets : trueproperty pCreateDebugTargets : trueproperty pCreateOptimizedTargets : trueproperty pCreateProfiledTargets : false-- Whether to compile anything.property pShouldBuild : trueproperty pMakeStationeryScript : "makeStat.met"property pStationeryName : "LibraryStationery"property pDirsToCreate : {Â	{relPath:"", name:"include"}, Â	{relPath:"", name:"lib"}, Â	{relPath:"lib", name:pStationeryName}}global gProjectDataon ProjectData(projName, features, aFileData)		if (count characters of projName) > 18 then		set projName to characters 1 through 18 of projName as string	end if		tell application "CodeWarrior IDE"				if features does not contain "C" and features does not contain "C++" then			--error "Project " & projName & "'s default language (a feature) must be C or C++."			copy "C" to end of features		end if		set myFeatures to features				return {name:projName, features:myFeatures, rsrcs:{}, settings:Â			{Prefix File:"", ppcProject:{}}, projLibs:{}, sysPaths:{}, fileData:Â			aFileData}			end tellend ProjectDataon AddProject(projData)	copy projData to end of gProjectDataend AddProjecton AddSimpleProject(projName, features, section)	AddProject(ProjectData(projName, features, {mkFileData(section)}))end AddSimpleProjecton AddSimpleProjectListFiles(projName, features, section, fileList)	AddProject(ProjectData(projName, features, {mkFileDataListFiles(section, fileList)}))end AddSimpleProjectListFileson AddSimpleProjectExceptFiles(projName, features, section, fileNotList)	AddProject(ProjectData(projName, features, {mkFileDataExceptFiles(section, fileNotList)}))end AddSimpleProjectExceptFileson mkFileData(section)	if (section does not end with ":") then set section to section & ":"	return {projPath:section, fileList:GetFileNames(section), fileNotList:{}}end mkFileDataon mkFileDataListFiles(section, fileList)	if (section does not end with ":") then set section to section & ":"	return {projPath:section, fileList:fileList, fileNotList:{}}end mkFileDataListFileson mkFileDataExceptFiles(section, fileNotList)	if (section does not end with ":") then set section to section & ":"	return {projPath:section, fileList:GetFileNames(section), fileNotList:fileNotList}end mkFileDataExceptFileson DataPlusPrefixFile(dataRec, prefix)	tell application "CodeWarrior IDE"				set the Prefix File of dataRec's settings to prefix		return dataRec			end tellend DataPlusPrefixFileon SetProjectData()		-- Not Okay under Mach-O	AddSimpleProject("mitsock", {}, "connect:mitsock")		AddProject(ProjectData("ncbi", {"winprefix"}, {Â		mkFileDataExceptFiles("corelib:", {"drwnflpt.c", "drwnfspc.c", "drwnmfls.c", "ncbiargs.c", "ncbimain.c"}), Â		mkFileData("corelib:morefile:"), Â		mkFileDataListFiles("connect:", {"ncbibuf", "ncbisock", "urlquery"}), Â		mkFileData("ctools:"), Â		mkFileDataExceptFiles("asnlib:", {"asncode.c", "asntool.c"})}))		AddProject(ProjectData("ncbiobj", {}, {Â		mkFileDataExceptFiles("object:", {"objmime.c"}), Â		mkFileDataExceptFiles("access:", {"strucapi.c"}), Â		mkFileData("api:"), Â		mkFileDataExceptFiles("ddv:", {"ddvmain.c"})}))		AddSimpleProjectExceptFiles("ncbicdr", {}, "cdromlib", {"acccn3ds.c", "accentr.c", "accmmdbs.c", "accutils.c"})		AddSimpleProjectExceptFiles("ncbidesk", {}, "desktop", {"sdisplay.c"})		AddSimpleProject("ddvlib", {}, "ddv")		AddProject(DataPlusPrefixFile(ProjectData("ncbimmdb", {}, {Â		mkFileDataListFiles("biostruc:", {Â			"corematx", "dvncode", "objmmdb1", "objmmdb2", "objmmdb3", "mmdbapi", Â			"mmdbapi1", "mmdbapi2", "mmdbapi3", "mmdbapi4", "mmdbentr", "vastsubs", Â			"prunebsc"}), Â		mkFileDataListFiles("object:", {Â			"objmime"}), Â		mkFileDataListFiles("access:", {Â			"strucapi"}), Â		mkFileDataListFiles("biostruc:cn3d:", {Â			"objcn3d"}), Â		mkFileDataListFiles("biostruc:cdd:", {Â			"objcdd", "cddutil", "cddposutil", Â			"thrdalgs", "thrdatd", "thrdbwfi", "thrdcpal", Â			"thrdcpll", "thrdcprl", "thrdcxei", "thrddgri", "thrdrsmp", Â			"thrdsal0", "thrdsalr", "thrdsalu", "thrdsgoi", "thrdslo0", Â			"thrdslor", "thrdslou", "thrdspci", "thrdspea", "thrdspel", Â			"thrdspni", "thrdttb0", "thrdttbi", "thrdzsc"})}), "gif.pfx"))		AddSimpleProject("ncbiNacc", {}, "cdromlib")		AddSimpleProject("vibnet", {}, "network:vibnet")		AddSimpleProject("ncbitool", {}, "tools")		AddSimpleProject("netentr", {}, "network:entrez:client")		AddSimpleProjectExceptFiles("ncbibls3", {}, "network:blast3:client", {"blastcl3.c"})		AddSimpleProjectExceptFiles("ncbiid1", {}, "network:id1arch", {"idfetch.c"})		AddSimpleProjectExceptFiles("ncbimla", {}, "network:medarch:client", {"sybmed.c"})		AddProject(DataPlusPrefixFile(ProjectData("ncbitxc2", {}, {Â		mkFileDataExceptFiles("network:taxon1:taxon2:", {"txcproc.c"}), Â		mkFileDataExceptFiles("network:taxon1:common:", {"checkid.c"})}), "tax2.pfx"))		AddSimpleProject("vibrant", {"winprefix"}, "vibrant")		AddSimpleProjectListFiles("ncbiconn", {"winprefix"}, "connect", Â		{"ncbi_buffer", "ncbi_socket", "ncbi_core", "ncbi_core_c", "ncbi_util", "ncbi_priv", Â			"ncbi_ansi_ext", "ncbi_connection", "ncbi_connector", "ncbi_connutil", Â			"ncbi_file_connector", "ncbi_host_info.c", "ncbi_http_connector", Â			"ncbi_memory_connector", "ncbi_server_info", "ncbi_service", Â			"ncbi_service_connector", "ncbi_dispd", "ncbi_lbsmd_stub", Â			"ncbi_socket_connector", "ncbi_sendmail"})		AddSimpleProjectExceptFiles("netcli", {}, "network:nsclilib", {"ni_encr.c", "ni_list.c", "ni_lib.c"})	end SetProjectData---- Global variables--global gStartupDiskglobal gHomeDirglobal gMWrootglobal gMWCWfolderglobal gDistribRootglobal gAccessRootglobal gProjectsDirglobal gSourceDirglobal gIncludeDirglobal gRsrcsDirglobal gMakeDirglobal gStationeryDiron GetFileNames(relPath)	set theFiles to list folder (gSourceDir & relPath) without invisibles	set theFiles to EndsWith(theFiles, ".c") -- Assume C projects not C++		return theFilesend GetFileNameson EndsWith(aList, suffix)	set newList to {}	repeat with f in aList		if (f ends with suffix) then			set newList to newList & (f as string)		end if	end repeat		return newListend EndsWithon CopyHeaders()	tell application "Finder"				set corelibFolder to folder (gDistribRoot & "corelib")				my UpdateRenameHeader("ncbilcl.met", corelibFolder, "ncbilcl.h", "")			end tellend CopyHeaderson ResolveAlias(pathname)	tell application "Finder"		--if the last character of pathname is ":" then error "Don't use a trailing colon with ResolveAlias."		if exists folder pathname then return pathname & ":"		if exists alias file pathname then return the original item of alias file pathname as string		error "The folder (or alias) '" & pathname & "' doesn't exist."	end tellend ResolveAliason IsOSX()	tell application "Finder"				set vers to the version as text				if second character of vers is equal to "." then			set vers to "0" & vers		end if				return vers > 10 or vers = 10			end tellend IsOSXon stripVolName(macPath)	set saveTID to get text item delimiters of AppleScript	set text item delimiters of AppleScript to ":"	set strippedPath to (rest of text items of macPath) as string	set text item delimiters of AppleScript to saveTID	return strippedPathend stripVolNameon HomeDir()	tell application "Finder"				if my IsOSX() then			return the home as string			-- return my stripVolName(home as string)		else			return gStartupDisk		end if			end tellend HomeDiron ModuleRoot()		if pUsingCPlusPlus then		set subFolder to "cxx"	else		set subFolder to "ncbi"	end if		set modRoot to ""	try		set modRoot to ResolveAlias(gMWroot & subFolder)	on error		try			set modRoot to ResolveAlias(gHomeDir & subFolder)		end try	end try		return modRootend ModuleRooton AccessRoot()	if my IsOSX() then		-- strip off the volume name at the front.		return my stripVolName(gDistribRoot)	else		return gDistribRoot	end ifend AccessRooton MWRootDir()		set mwRoot to ""	set mwLocations to {gStartupDisk, gStartupDisk & "Applications:", gStartupDisk & "Applications (Mac OS 9):", Â		gStartupDisk & "AppsLocal:", gHomeDir, gHomeDir & "Applications:", gHomeDir & "Applications (Mac OS 9):", Â		gHomeDir & "AppsLocal:"}	repeat with mwVersion from 8 to 9		set dirName to "Metrowerks CodeWarrior " & mwVersion & ".0"		repeat with mwLoc in mwLocations			try				set mwRoot to ResolveAlias(mwLoc & dirName)				return mwRoot			end try		end repeat	end repeat		error "Can't find the Metrowerks CodeWarrior folder."	end MWRootDiron GetMyPath()	set myPath to path to me as string	if myPath contains "Script Editor" then		-- Oops! running under script editor. 'me' is Script Editor not this script.		-- use the location this script is supposed to be in.		if pUsingCPlusPlus then			return gDistribRoot & "compilers:mac_prj"		else			return gDistribRoot & "make:"		end if	else		tell application "Finder"			return container of myPath		end tell	end ifend GetMyPathon SetGlobals()	tell application "Finder"				set gProjectData to {}				set gStartupDisk to startup disk as string		set gHomeDir to my HomeDir()		set gMWroot to my MWRootDir()		set gMWCWfolder to gMWroot & "Metrowerks CodeWarrior:"				set gDistribRoot to my ModuleRoot()		set gAccessRoot to my AccessRoot()				set gIncludeDir to gDistribRoot & "include:"		if pUsingCPlusPlus then			set gSourceDir to gDistribRoot & "src:"			set gProjectsDir to gDistribRoot & "compilers:mac_prj:lib:"			set gRsrcsDir to gDistribRoot & "compilers:mac_prj:"		else			set gSourceDir to gDistribRoot			set gProjectsDir to gDistribRoot & "lib:"			set gRsrcsDir to gDistribRoot & "link:macmet:"		end if		set gStationeryDir to gProjectsDir & pStationeryName & ":"		set gMakeDir to my GetMyPath()			end tellend SetGlobalson HeaderExists(header, headerDir)	tell application "Finder"				if headerDir is "" then set headerDir to folder gIncludeDir		return exists file header of headerDir			end tellend HeaderExistson IsOlderThan(fileA, fileB)	tell application "Finder"				return (the modification date of fileA < the modification date of fileB)			end tellend IsOlderThanon UpdateRenameHeader(canonicalName, canonicalDir, dotHName, dotHDir)	tell application "Finder"				set needRename to (dotHName is not "")		if not needRename then set dotHName to canonicalName		if dotHDir is "" then set dotHDir to folder gIncludeDir				-- This file is only present if the script was interrupted.		if needRename and my HeaderExists(canonicalName, dotHDir) then			delete file canonicalName of dotHDir		end if				-- The native config file.		-- If it's missing, assume this is a prepared distribution and the header is already up-to-date.		if not my HeaderExists(canonicalName, canonicalDir) then return		set canonicalFile to file canonicalName of canonicalDir				set needCopy to true		if my HeaderExists(dotHName, dotHDir) then			set dotHFile to file dotHName of dotHDir			if my IsOlderThan(dotHFile, canonicalFile) then				delete dotHFile			else				set needCopy to false			end if		end if				if needCopy then			my DuplicateFile(canonicalFile, dotHDir)			if needRename then set name of file canonicalName of dotHDir to dotHName		end if			end tellend UpdateRenameHeaderon DuplicateFile(fileToCopy, destFolder)	tell application "Finder"		try			duplicate fileToCopy to destFolder		on error msg number errnum			if errnum is -43 then				(* if the file was just newly created (e.g. a clean install or cvs update)				the finder gets this error trying to copy a file from it.				Opening its folder with the finder fixes this.				We do this in a try block so we aren't always flashing the window open				for this somewhat rare occurrence.				*)				open (container of fileToCopy)				close first Finder window				duplicate fileToCopy to destFolder			else				error msg number errnum			end if		end try	end tellend DuplicateFileon SetUserPaths()	tell application "CodeWarrior IDE"				set pathsToAdd to {}		-- Put the ncbi root, recursively at the end of the user paths.		-- we did not do this in makeStationery because this is the only machine specific path.		-- all those set in the stationery are relative or universal.		copy {name:gAccessRoot, recursive:true, origin:absolute} to end of pathsToAdd		Set Preferences of panel "Access Paths" to {User Paths:pathsToAdd}			end tellend SetUserPathson SetSysPaths()	-- This was all done in the Stationery project.end SetSysPathson SetupTarget(proj, targetIndex)	tell application "CodeWarrior IDE"				set targetName to name of target targetIndex of project document 1		if targetName contains "Carbon" then			set targetAPI to "Carbon"		else if targetName contains "Mach-O" then			if not my IsOSX() then return -- do not try to populate Mach-O targets on pre-OS X systems.			set targetAPI to "Mach-O"		else if targetName contains "Win32" then			set targetAPI to "Win32"		end if				if targetName contains "Debug" then			set targetDebug to true			if pCreateProfiledTargets then				set targetProfile to true			else				set targetProfile to false			end if		else -- if targeName contains "Final" then			set targetDebug to false			set targetProfile to false		end if				-- NOTE: no Profile targets. if pCreateProfiledTargets, we make the debug targets also profile-able.				set the current target of project document 1 to target targetIndex of project document 1				-- initialize variables		set projRsrcs to {}		set projFeatures to {}		set sysPaths to {}				-- Grab the fields of our project record and store them in local variables.		set projName to proj's name		set projSettings to proj's settings		try			set projFeatures to proj's features		end try		try			set sysPaths to proj's sysPaths		end try		try			set projRsrcs to proj's rsrcs		end try		set projLibs to proj's projLibs		set projFileData to proj's fileData				-- mitsock library isn't needed (and won't compile) as Mach-O		if projName is "mitsock" and targetAPI is not "Carbon" then			return		end if				-- Figure out what our output file and input libraries will be named.		set targetFilename to projName				if targetAPI is "Carbon" then			set targetFilename to targetFilename & "_C"		else if targetAPI is "Mach-O" then			set targetFilename to targetFilename & "_M"		else if targetAPI is "Win32" then			set targetFilename to targetFilename & "_W"		end if				-- Debug or not.		if not targetDebug then			set targetFilename to targetFilename & "_O" -- for Optimized.		else			set targetFilename to targetFilename & "_D"		end if				set targetFilename to targetFilename & ".lib"				-- Get Preference Panel names.		if targetAPI is "Mach-O" then			set targetPanelName to "PPC Mac OS X Project"			set codeGenPanelName to "PPC CodeGen Mach-O"		else if targetAPI is "Win32" then			set targetPanelName to "x86 Project"			set codeGenPanelName to "x86 CodeGen"		else			set targetPanelName to "PPC Project"			set codeGenPanelName to "PPC CodeGen"		end if				-- Set the name of the output file (the application)		Set Preferences of panel targetPanelName to {File Name:targetFilename}				-- If we have any per-project override settings, set them.		if (count ppcProject of projSettings) > 0 then			Set Preferences of panel targetPanelName to ppcProject of projSettings		end if				my SetUserPaths()		-- my SetSysPaths() -- done in the stationery project.				-- Add per-project system paths.		set pathsToAdd to {}		repeat with i in sysPaths			copy {name:i, recursive:false, origin:absolute} to end of pathsToAdd		end repeat		if (count pathsToAdd) > 0 then Â			Set Preferences of panel "Access Paths" to {System Paths:pathsToAdd}				-- Set the appropriate prefix file.		set prefixFile to Prefix File of projSettings		if targetAPI is "Win32" and projFeatures contains "winprefix" then			set prefixFile to "Win32Headers.pch"		else			if prefixFile is "" then				set prefixFile to "CarbonPrefix.h"			else				set prefixFile to "Carbon-" & prefixFile			end if		end if		if prefixFile is not "" then			Set Preferences of panel "C/C++ Compiler" to {Prefix File:prefixFile}		end if				-- Are we assuming a .c or a .cpp extension?		if projFeatures contains "C++" then			set fileExtension to pCPlusPlusExtension		else			set fileExtension to ".c"		end if			end tell		-- Add source files.	repeat with group in projFileData		set projPath to projPath of group		set fileList to group's fileList				set filesToAdd to {}		repeat with i in fileList			if i does not contain "." then set i to i & fileExtension			try -- ignore it if the file doesn't exist.								-- NOTE: if the following line is within a tell "Codewarrior" block then				--  the following Add Files command will fail.				copy alias (gSourceDir & projPath & i) to end of filesToAdd			end try		end repeat				tell application "CodeWarrior IDE"			Add Files filesToAdd						-- Take out source files that do not belong.			set fileNotList to group's fileNotList			Remove Files fileNotList		end tell	end repeat		tell application "CodeWarrior IDE"				-- take care of debugging and profiling settings		if targetDebug then			set the debug of every target file of target targetIndex Â				of project document 1 to true		end if						if targetAPI is "Carbon" then			if targetProfile then				(* ===== Panel PPC Processor ===== *)				Set Preferences of panel codeGenPanelName to Â					{Use Profiler:true}			else				(* ===== Panel PPC Processor ===== *)				Set Preferences of panel codeGenPanelName to Â					{Use Profiler:false}			end if			(*		-- Because of a CW bug can't turn on Mach-O profiling from a script.		else if targetAPI is  "Mach-O"					if targetProfile then				(* ===== Panel PPC Processor ===== *)				Set Preferences of panel codeGenPanelName to Â					{Mach-O Profiling:metrowerks}			else				(* ===== Panel PPC Processor ===== *)				Set Preferences of panel codeGenPanelName to Â					{Mach-O Profiling:off}			end if			*)		end if						-- Add resources.		if targetAPI is not "Win32" then			set filesToAdd to {}			repeat with i in projRsrcs				copy gRsrcsDir & i to end of filesToAdd			end repeat						Add Files filesToAdd		end if				Reset File Paths			end tellend SetupTargeton CreateFolders()	tell application "Finder"				repeat with i in pDirsToCreate			set pth to relPath of i			if pth is not "" then set pth to pth & ":"						-- display dialog "Folder? " & (gDistribRoot & pth & i's name) buttons {"OK"} default button 1						if not (exists folder (gDistribRoot & pth & i's name)) then				-- display dialog "make Folder: " & i's name & " at: " & (gDistribRoot & pth) buttons {"OK"} default button 1								make new folder at folder (gDistribRoot & pth) with properties {name:i's name}			end if		end repeat			end tellend CreateFolderson CreateProject(proj)	tell application "CodeWarrior IDE"				-- This statement doesn't work, because AppleScript is broken.		if proj is {} then return				try			get proj's name		on error			return		end try				set projFilename to proj's name & pProjectFileExtension		set projPathname to gProjectsDir & projFilename		if pAlwaysCreateProjects or not (exists file projPathname of application "Finder") then						try				close (the first project document whose name is projFilename)			end try						set stationeryName to (gStationeryDir & pStationeryName & pProjectFileExtension)			-- display dialog "creating project: " & projPathname & return & "from: " & stationeryName Â			--	buttons {"OK"} default button 1						Create Project projPathname from stationery alias stationeryName			if the name of window 1 is "Project Messages" then				close first window -- "close window 1" becomes "Close Window 1" (different event)			end if						-- display dialog "created project: " & projPathname						repeat with i from 1 to (count targets of project document 1)				my SetupTarget(proj, i)			end repeat						set the current target of project document 1 to target 1 of project document 1						Close Project					end if			end tellend CreateProjecton CreateAllProjects()		repeat with proj in gProjectData		CreateProject(proj)	end repeat	end CreateAllProjectsglobal gTargets2Build-- get names of files in thePath that start with "Build"on GetMakeFileNames(thePath)	set theFiles to list folder (thePath) without invisibles	set newList to {}	repeat with f in theFiles		if (f begins with "Build") then			set newList to newList & (f as string)		end if	end repeat		return newListend GetMakeFileNameson AddtoList(aList, anItem)	if (aList does not contain anItem) then		copy anItem to end of aList	end ifend AddtoListon FindTargets2Build()	set gTargets to {}	if pCreateCarbonTargets then		set gTargets to gTargets & "Carbon"	end if	if pCreateMachOTargets then		set gTargets to gTargets & "Mach-O"	end if	if pCreateWinTargets then		set gTargets to gTargets & "Win32"	end if		set gBuildTypes to {}	if pCreateDebugTargets or pCreateProfiledTargets then		set gBuildTypes to gBuildTypes & "Debug"	end if	if pCreateOptimizedTargets then		set gBuildTypes to gBuildTypes & "Final"	end if		-- set gTargets to {"Carbon", "Mach-O"}	-- set gBuildTypes to {"Final", "Debug", "Profile"}		set makeFiles to my GetMakeFileNames(gMakeDir)	if (count items of makeFiles) is 0 then		set makeFiles to gTargets -- if nothing, make everything.	end if		set gTargets2Build to {}		repeat with f in makeFiles		set thisTarget to ""		set targetSet to false		repeat with t in gTargets			if f contains t then				set thisTarget to contents of t				set targetSet to true				exit repeat			end if		end repeat				set typeSet to false		repeat with t in gBuildTypes			if f contains t then				set thisTarget to thisTarget & " " & t				set typeSet to true				exit repeat			end if		end repeat				if targetSet and typeSet then			my AddtoList(gTargets2Build, thisTarget)		else if (targetSet or typeSet) then			if not typeSet then				repeat with t in {"Final", "Debug"}					AddtoList(gTargets2Build, (thisTarget & " " & t))				end repeat			end if			if not targetSet then				repeat with t in gTargets					AddtoList(gTargets2Build, (t & thisTarget))				end repeat			end if		end if	end repeatend FindTargets2Buildon OkaytoBuild(targetName)	repeat with t in gTargets2Build		if (targetName contains t) then			return true		end if	end repeat	return falseend OkaytoBuildon BuildProject(projName)	tell application "CodeWarrior IDE"		open (gProjectsDir & projName & pProjectFileExtension)		if the name of window 1 is "Project Messages" then			close first window -- "close window 1" becomes "Close Window 1" (different event)		end if		repeat with i from 1 to (count targets of project document 1)			-- do we want to build this target?			if my OkaytoBuild(name of target i of project document 1) then								set the current target of project document 1 to target i of project document 1				Make Project				-- If there were compiler warnings, then a compiler window will be in front.				-- For whatever reason, this causes the next "set the current target..." to fail.				-- So check for the window and close it.				if the name of window 1 is "Errors & Warnings" then					close first window -- "close window 1" becomes "Close Window 1" (different event)				end if			end if		end repeat		set the current target of project document 1 to target 1 of project document 1		Close Project	end tellend BuildProjecton BuildAllProjects()	FindTargets2Build()	repeat with proj in gProjectData		try			set projName to proj's name		on error			set projName to ""		end try		-- This statement doesn't work, because AppleScript is broken.		if proj is not {} then			if projName is not "" then				BuildProject(projName)			end if		end if	end repeat	end BuildAllProjectson GuaranteeStationery()	tell application "Finder"		-- get rid of any old copy.		try			if (exists folder (gStationeryDir)) and Â				(exists file (gStationeryDir & pStationeryName & pProjectFileExtension)) then				delete file (gStationeryDir & pStationeryName & pProjectFileExtension)			end if		end try		if not (exists folder (gStationeryDir)) then			make new folder at folder (gProjectsDir) with properties {name:pStationeryName}		end if		-- copy it.		my DuplicateFile(file (gRsrcsDir & pStationeryName & pProjectFileExtension), folder gStationeryDir)		-- make sure there is nothing else in the folder.		my CleanupFolder(gStationeryDir, pStationeryName & pProjectFileExtension)	end tellend GuaranteeStationery-- Delete everything in the folder 'thePath' except the saveFile.on CleanupFolder(thePath, saveFile)	repeat with f in list folder (thePath) with invisibles		if (f as string is not saveFile) then			try				tell application "Finder" to delete folder (thePath & f)			end try			try				tell application "Finder" to delete file (thePath & f)			end try		end if	end repeatend CleanupFolderon CleanupFiles(thePath)	-- get rid of all the files and folders starting with xxxx in thePath	repeat with f in list folder (thePath) without invisibles		if ((f as string) begins with "xxxx") then			try				tell application "Finder" to delete folder (thePath & f)			end try			try				tell application "Finder" to delete file (thePath & f)			end try		end if	end repeat	-- delete the stationery folder.	try		tell application "Finder" to delete folder gStationeryDir	end tryend CleanupFileson SignalCompletion()		beep	end SignalCompletionwith timeout of 60000 seconds		SetGlobals()	SetProjectData()		CreateFolders()	CopyHeaders()		tell application "CodeWarrior IDE" to activate		GuaranteeStationery()	CreateAllProjects()		if pShouldBuild then		BuildAllProjects()	end if		CleanupFiles(gProjectsDir)		SignalCompletion()	end timeout